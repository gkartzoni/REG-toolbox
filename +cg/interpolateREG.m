function [ regHR_updated ] = interpolateREG(regHR, regLR )% INTERPOLATEREG% interpolate control grid resolution by increasing the resolution by two%%   Detailed explanation goes here% Input :%   - regLR structure to be interpolate%    - regHR structure to be updated with interpolated values% Output:%   - regHR%kernels and steps remains the same in HR and LRfor i=1 : length(regHR.img)    if i == regHR.refIdx  continueendstepModifier = size(regHR.img(i).data) == size(regLR.img(i).data);regHR.img(i).cg=cg.initialize( size(regHR.img(i).data), regLR.img(i).cg.step./(stepModifier+1), regLR.img(i).cg.margin*2);size(regHR.img(i).cg.grid)regHR.img(i).cg.grid = cg.interpolateGrid(regLR.img(i).cg.grid, size(regHR.img(i).cg.grid), 2-stepModifier);    if size(regLR.img(i).D) == [size(regLR.img(i).data), 3],        printf("interpolating LR displacement field \n");                           regHR.img(i).D = cat(4, ...            interpolate(regLR.img(i).D(:,:,:,1), size(regHR.img(i).data) ), ...            interpolate(regLR.img(i).D(:,:,:,2), size(regHR.img(i).data) ), ...            interpolate(regLR.img(i).D(:,:,:,3), size(regHR.img(i).data) )   );    else        regHR.img(i).D=single(zeros( [size(regHR.img(i).data) 3] ));    endendregHR_updated = regHR;end